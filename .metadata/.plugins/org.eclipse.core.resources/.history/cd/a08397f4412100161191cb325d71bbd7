package sockets;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;
import java.sql.Time;
import java.util.concurrent.TimeUnit;

import javax.swing.JLabel;
import javax.swing.JProgressBar;
public class TCPClient implements Runnable{
	private Socket clientSocket = null; //socket cliente
	
	private InputStream inputStream = null;
	private OutputStream fileOutputStream = null;
	private boolean isConnected = false;
	private boolean temp = true;
	private long totalLength;
	private JLabel label;
	private JProgressBar progress;
	private File dstFile = null; //arquivo que sera criado
	private String destinationPath;
	private JLabel info;
	private String ip;
	private int serverPort;
	public TCPClient(String dest, JLabel label, JProgressBar progress, JLabel info, String ip, int serverPort){
		this.label = label;
		this.destinationPath = dest;
		this.progress = progress;
		this.info = info;
		this.ip = ip;
		this.serverPort = serverPort;
	}
	
	public void finish()
	{
		this.temp = false;
	}
	
	public void run()
	{
		//accept connection
		while(!isConnected)
		{
			try
			{
				clientSocket = new Socket(this.ip, serverPort); //conectando com host na porta do servidor aberta
				isConnected = true;
				this.label.setText("Connected.");
				inputStream = clientSocket.getInputStream();
			}
			catch(Exception e)
			{
				this.info.setText("Erro de conexao em cliente: " + e.getMessage());
			}
		}
		this.progress.setMinimum(0);
		this.progress.setMaximum(100);
		this.progress.setValue(0);
		long count = 0;
		this.label.setText("Downloading File. Please Wait...");
		//variaveis para calculo do tempo estimado
		long seconds;
		while(temp)
		{
			try
			{
				//recebendo resposta do servidor:
				int len;
				byte[] readPacket = new byte[1024]; //criando pacote
				//calculo do RTT: começa antes de escrever e verifica logo apos terminar
				
				//lendo o nome do arquivo
				DataInputStream clientData = new DataInputStream(inputStream);
				String fileName = clientData.readUTF();
				destinationPath += fileName; //agregando o nome do arquivo ao destino
				dstFile = new File(destinationPath);
				System.out.println("DESTINO: " + destinationPath);
				this.totalLength = clientData.readLong(); //tamanho total do arquivo em bytes
				long kilobytes = this.totalLength/1024;
				//stream de saida: para path de destino
				fileOutputStream = new FileOutputStream(dstFile);
				if(!dstFile.exists()) throw new Exception();
				dstFile.setWritable(true); //permitindo escrita
				
				while((len = inputStream.read(readPacket)) > 0 && temp)
				{
					long time = System.currentTimeMillis()/1000; //tempo em segundos
					long RTT = System.nanoTime();
					fileOutputStream.write(readPacket, 0, len); //escrevendo no diretorio destino
					RTT = System.nanoTime() - RTT;
					this.info.setText("RTT = " + RTT + " nanosegundos");
					seconds = (long) (RTT/1000000000); //tempo para 1KB ser enviado em 1s
					
					//totalSeconds = kilobytes/seconds; //total de segundos faltando
					//hours = totalSeconds/3600;
					//minutes = (totalSeconds%3600)/60;
					//seconds = (totalSeconds%3600)-(minutes*60);
					count += len;
					int value = (int)((count*100)/(totalLength));
					this.progress.setValue(value); //atualizando barra de progresso
					this.label.setText(value + "% " + hours + "h" + minutes + "min" + seconds + "sec remaining.");
				}
				
				if(len <= 0) break;
			}
			catch(Exception e)
			{
				if(e.getMessage() == null)this.info.setText("Diretorio destino inexistente!");
				else this.info.setText("Erro em operacao de cliente: " + e.getMessage());
				System.out.println("Erro em cliente: " + e.getMessage());
				
			}
		}
		this.progress.setValue(100);
		try {
			this.label.setText("Download Finished. Check the destiny Path.");
			clientSocket.close();
			fileOutputStream.close();
			
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		
			
	}
}
